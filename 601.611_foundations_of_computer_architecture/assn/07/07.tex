\documentclass[12pt]{article}
\usepackage[margin=1.0in]{geometry}
\usepackage{setspace}
\usepackage{titling}

\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage[shortlabels]{enumitem}

\setstretch{1.5}
\setlength{\droptitle}{-8em}

\begin{document}

  \title{605.611 - Foundations of Computer Architecture \\ Assignment 07 - MIPS Datapath\vspace{-0.5em}}
  \author{Sabbir Ahmed}
  \maketitle
  \vspace{-1em}

  \begin{enumerate}

  \item[4.1] Consider the following instruction:

  Instruction: \texttt{AND Rd, Rs, Rt}

  Interpretation: \texttt{Reg[Rd] = Reg[Rs] AND Reg[Rt]}

  \begin{enumerate}[label=4.1.\arabic*]
    \item What are the values of control signals generated by the control in Figure 4.2 for the above instruction?

    \textbf{Answer:}

    \begin{center}
      \begin{tabular}{|c|c|c|c|c|c|c|}
      \hline
      RegDst & Branch & MemToReg & ALUOp & MemWrite & ALUSrc & RegWrite \\
      \hline
      1 & 0 & 0 & 10 (AND) & 0 & 0 & 1 \\
      \hline
      \end{tabular}
    \end{center}

    \item Which resources (blocks) perform a useful function for this instruction?

    \textbf{Answer:} All of the resources but the branch adder unit and the write port of the registers.

    \item Which resources (blocks) produce outputs, but their outputs are not used for this instruction? Which resources produce no outputs for this instruction?

    \textbf{Answer:} Write port of the registers and the branch adder do not use their outputs for this instruction. And all the resources produce outputs for this instruction.

  \end{enumerate}

  \item[4.6] When silicon chips are fabricated, defects in materials (e.g., silicon) and manufacturing errors can result in defective circuits. A very common defect is for one wire to affect the signal in another. This is called a cross-talk fault. A special class of cross-talk faults is when a signal is connected to a wire that has a constant logical value (e.g., a power supply wire). In this case we have a stuck-at-0 or a stuck- at-1 fault, and the affected signal always has a logical value of 0 or 1, respectively. The following problems refer to bit 0 of the Write Register input on the register file in Figure 4.24.

  \begin{enumerate}[label=4.6.\arabic*]

    \item Let us assume that processor testing is done by filling the PC, registers, and data and instruction memories with some values (you can choose which values), letting a single instruction execute, then reading the PC, memories, and registers. These values are then examined to determine if a particular fault is present. Can you design a test (values for PC, memories, and registers) that would determine if there is a stuck-at-0 fault on this signal?

    \textbf{Answer:} If the processor has a stuck-at-0 fault on the Write Register, then only the even registers are accessible by the instructions. We can test for this fault by attempting to write to an odd register and then checking its values.

    We can test by loading the registers \texttt{\$t2} with 0 and \texttt{\$t3} with 1 and then executing:

    \texttt{ADD \$t3, \$t2, \$t2}

    If this instruction was executed successfully, \texttt{\$t3} would have the value of 0.

    \item Repeat 4.6.1 for a stuck-at-1 fault. Can you use a single test for both stuck-at-0 and stuck-at-1? If yes, explain how; if no, explain why not.

    \textbf{Answer:} Analogous to the stuck-at-o fault, if the processor has a stuck-at-1 fault on the Write Register, then only the odd registers are accessible by the instructions. We can use the same test as earlier with the registers flipped.

    We can test by loading the registers \texttt{\$t3} with 0 and \texttt{\$t2} with 1 and then executing:

    \texttt{ADD \$t2, \$t3, \$t3}

    If this instruction was executed successfully, \texttt{\$t2} would have the value of 0.

    The fault tests were done by assigning specific values to registers. Since there are no ways to assign both values to the registers within the same clock cycle, it is not possible to use the same test to detect both of the faults.

    \item If we know that the processor has a stuck-at-1 fault on this signal, is the processor still usable? To be usable, we must be able to convert any program that executes on a normal MIPS processor into a program that works on this processor. You can assume that there is enough free instruction memory and data memory to let you make the program longer and store additional data. Hint: the processor is usable if every instruction ``broken'' by this fault can be replaced with a sequence of ``working'' instructions that achieve the same effect.

    \textbf{Answer:} If the processor has a stuck-at-1 fault on MemWrite, half of the registers become unavailable for use with any instructions. However, it is possible to execute instructions using the remaining odd registers. 

    \item Repeat 4.6.1, but now the fault to test for is whether the ``MemRead'' control signal becomes 0 if RegDst control signal is 0, no fault otherwise.

    \textbf{Answer:} To test this fault, we need to execute an instruction that yields a value of 1 for ``MemRead''. Load instructions work in this case, as well as sets RegDst to 0. We can test by executing a load instruction with the immediate value of 0. We can check the value of the register loaded to and it should result in a different value since no memory was read. However, since the value read is random, it is also possible to read the immediate value that was loaded. Therefore, this test may have to be done several times with random immediate values.

    \item Repeat 4.6.4, but now the fault to test for is whether the ``Jump'' control signal becomes 0 if RegDst control signal is 0, no fault otherwise.

    \textbf{Answer:} To test this fault, we need to execute an instruction that yields a value of 1 for ``Jump''. Jump instructions work in this case. Since jump does not write to any register, RegDst is set to ``don't care'. Since it is not possible to control the value of RegDst, there are no reliable tests to check this fault.

    \item Add unit in the upper right, the ALU result bit 0 and result bit 31 are stuck at 0 \& 1.  Note that this will always work correctly or always fail.

    \textbf{Answer:} 

  \end{enumerate}

  \item[2] Program the microcode instruction, similar to the micro table we did in class, for an \texttt{R} instruction, \texttt{I} instruction, and \texttt{sll} instruction.  Do the same for an \texttt{andi} instruction.  What problems do you see for the instructions \texttt{sll} and \texttt{andi} instructions?

    \begin{center}
      \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline
      Instruction & RegDst & Branch & MemToReg & ALUOp & MemWrite & ALUSrc & RegWrite \\
      \hline
      \texttt{subu} & 1 & 0 & 0 & 10 (SUB) & 0 & 0 & 1 \\
      \hline
      \texttt{subiu} & 0 & 0 & 0 & 00 (??) & 0 & 1 & 1 \\
      \hline
      \texttt{sll} & 1 & 0 & 0 & 10 (??) & 0 & 0 & 1 \\
      \hline
      \texttt{andi} & 0 & 0 & 0 & 00 (??) & 0 & 1 & 1 \\
      \hline
      \end{tabular}
    \end{center}

    The \texttt{I} instructions (\texttt{subiu}) and \texttt{andi} do not have an ALUOp designated for them. Therefore, the microtable used for \texttt{R} instructions do not work with them. \texttt{sll}, even if an \texttt{R} instruction with designated ALUOp values, does not specify the values of \texttt{shamt} as required by the instruction.

  \end{enumerate}

\end{document}
