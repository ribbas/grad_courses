
\section{Recommended Software Patterns in SST}
The following patterns can be considered appropriate to implement in the project:
\begin{enumerate}
    \item Façade pattern
    \item Interpreter pattern
\end{enumerate}

\subsection{Façade pattern}
The current method for a Client to interface the library is to create a derived class of Component and override its methods. While this approach provides extensive control over the functionality of crucial methods such as \texttt{void setup(unsigned int)}, \texttt{void finish(unsigned int)} and \texttt{bool tick(SST::Cycle\_t)}, it requires the Client to have extensive knowledge of the subsystems in the framework. The aforementioned methods, if overridden by the Client, must be implemented properly for the model and the simulation to be functional.

The following listing is an interface of a simple Component that simulates a primitive full adder hardware unit.

\begin{lstlisting}[language=c++]
#include <sst/core/component.h>
#include <sst/core/interfaces/stringEvent.h>
#include <sst/core/link.h>

class FullAdder : public SST::Component {
public:
    // register and manually configure each of the SST::Links
    // to their corresponding event handlers
    FullAdder(SST::ComponentId_t id, SST::Params& params);

    // implement logic for the model when it is being loaded into
    // the simulation
    void setup() override;

    // implement logic for the model when it is being unloaded from
    // the simulation
    void finish() override;

    // implement logic for the model on every clock cycle in
    // the simulation
    bool tick(SST::Cycle_t cycle);

    // event handlers for all the member SST::Link attributes
    void handle_opand1(SST::Event* event);
    void handle_opand2(SST::Event* event);
    void handle_cin(SST::Event* event);

    // register the component
    SST_ELI_REGISTER_COMPONENT(
        FullAdder, // class
        "fulladder", // element library
        "fulladder", // component
        SST_ELI_ELEMENT_VERSION(1, 0, 0),
        "SST parent model",
        COMPONENT_CATEGORY_UNCATEGORIZED)

    // port name, description, event type
    SST_ELI_DOCUMENT_PORTS(
        {"opand1", "Operand 1", {"sst.Interfaces.StringEvent"}},
        {"opand2", "Operand 2", {"sst.Interfaces.StringEvent"}},
        {"cin", "Carry-in", {"sst.Interfaces.StringEvent"}},
        {"sum", "Sum", {"sst.Interfaces.StringEvent"}},
        {"cout", "Carry-out", {"sst.Interfaces.StringEvent"}})

private:
    // SST parameters
    std::string clock;

    // SST links
    SST::Link *opand1_link, *opand2_link, *cin_link, 
        *sum_link, *cout_link;

    // other attributes
    std::string opand1, opand2, cin;
    SST::Output output;
};
\end{lstlisting}

This Component is a relatively simple example of a model that can be simulated in the SST framework. The hardware logic for the full adder will be implemented in the tick function, where the output values (\texttt{sum} and \texttt{cout}) are evaluated using the member attributes \texttt{opand1}, \texttt{opand2}, and \texttt{cin} after they are processed by their corresponding handlers.

Exposing all the complexity of the base methods to the Client can lead to many potential issues. One way to reduce the chances of such issues is to abstract away the steps and methods from the Client using a Facade design pattern. The library, in its current state, does not provide a method to call any of the constructors of the Simulation objects, such as Components and SubComponents. Execution of such objects is done through various command line tools. Even testing of the classes appear to be done through external tools and Python interpreters, which compare the outputs to the expected outputs rather than using asserts.

The following listing is a potential interface that may be possible with the integration of a Facade object into the project.

\begin{lstlisting}[language=c++]
#include <sst/core/facade.h>

bool customTickFunc(unsigned int cycle) {
    // do something
}

int main(int argc, char* argv[]) {
    SST::Facade* facade = new SST::Facade(argc, argv);
    SST::Component* component = facade->getComponent();

    component->register(
        FullAdder, // class
        "fulladder", // element library
        "fulladder", // component
        SST_ELI_ELEMENT_VERSION(1, 0, 0),
        "SST parent model",
        COMPONENT_CATEGORY_UNCATEGORIZED);
    component->registerStringEventPort("opand1", "Operand 1");
    ...

    component->overrideTick(&customTickFunc);
    component->setMPIRank(0);
    component->run();

    delete component;
    delete facade;

    return 0;
}
\end{lstlisting}

\subsection{Interpreter pattern}
