\documentclass[titlepage]{article}
\input{header.sty}

% Section 3:  Be sure that you understand from the rubric in the Syllabus how the number and type of patterns selected affects your grade.

% Section 3.1:  Make sure to explain why you have both AF and FM patterns here.  Is one implementing the other?
% Explain whether or not the variadic form is consistent with the pattern.  Just from the function signature that you've shown I'm not sure that it is.
% In general be sure to explain all of the roles of the pattern and how they are filled by the implementation or not.  Roles include not just the classes, but the relationships and methods, too.
% Explain how the implementation deals with issues that were part of our discussion, for example, how is the client configured with a particular ConcreteCreator?

% Section 3.2:  Is the Singleton implemented correctly?  Does it have any special features that help it deal with being instantiated in a multi-threaded environment, like locks, DCL or being instantiated at a particular place in the program?  Is it ever destroyed?

% Section 3.3:  Does the Strategy have a Context?  How is the ConcreteStrategy chosen?

% These aren't the only questions to ask about the patterns.


\title{Final Project}
\author{Sabbir Ahmed}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
In software engineering, design patterns are general, reusable solutions to commonly occurring problems \cite{source-making}. It is generally considered good practice to integrate design patterns into software products, especially large projects, since it allows the developers to focus their time and attention towards specific implementations. The purpose of this draft is to introduce an open-source project and present analysis on the software patterns within the implementation.

\section{Structural Simulation Toolkit (SST)}
The software that is being focused on in the final project is Structural Simulation Toolkit (SST). It is a simulation framework that prioritizes high performance computing (HPC) models \cite{sst}. Since SST is a large scale project with many stable extensions implemented for its kernel, the scope of the project will be limited to specific sections of the core repository. The repository is hosted on GitHub \cite{sst-repo}.

\section{Software Patterns Present in SST}
The following patterns can be observed to have been already implemented in the project:
\begin{enumerate}
    \item Abstract factory pattern
    \item Factory method pattern
    \item Singleton pattern
    \item Strategy pattern
\end{enumerate}
Other patterns are present in the project, such as C++ idioms (Include Guard Macro, enable\_if, etc.)

\subsection{Abstract Factory/Factory Method}
The abstract factory and factory method patterns are present in the \texttt{SST::Factory} class. In the repository, the class can be located at \texttt{factory.h}. In the repository, it is used to create several concrete classes, including \texttt{Component} and \texttt{Module} objects. The class also provides templated variadic methods to create concrete classes of generic classes, such as
\begin{lstlisting}[language=c++]
// src/sst/core/factory.h
/*
 * General function to create a given base class.
 *
 * @param type
 * @param params
 * @param args Constructor arguments
 */
template<class Base, class ... CtorArgs>
Base* Create(const std::string& type, CtorArgs&& ... args)
\end{lstlisting}

\subsection{Singleton}
The singleton pattern is present in the \texttt{SST::Factory} class. In the repository, the class can be located at \texttt{factory.h}. The class is used to instantiate other concrete simulation classes. SST requires simulation objects to be synchronized throughout the kernel, especially since they can be running on a distributed system where race conditions can become major issues. The software forces these simulation objects to be singletons.

\subsection{Strategy pattern}

The strategy pattern is present in the \texttt{SST::Core::Serialization::serializer} class. The class is implemented throughout multiple files in \texttt{serialization}, where it is overloaded in the files with various parameter types, with all the various versions of the class simply overloading the function call operator (\texttt{operator()}).

\bibliographystyle{plain}
\bibliography{ref}

\end{document}
