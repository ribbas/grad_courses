% Section 3.3:  Does the Strategy have a Context?  How is the ConcreteStrategy chosen?

\section{Software Patterns Present in SST}
The following patterns can be observed to have been already implemented in the project:
\begin{enumerate}
  \item Factory method pattern
  \item Singleton pattern
  \item Prototype pattern
        % \item Strategy pattern
\end{enumerate}
Other patterns are present in the project, such as C++ idioms (Include Guard Macro, enable\_if, etc.)

\input{abstractfactory.tex}

\input{singleton.tex}

\subsection{Prototype Pattern}
The Prototype pattern is present in the project, although in a very limited manner. Select \texttt{SST::Core::Interfaces} classes implement a \texttt{clone} method to provide the ability to copy instances of themselves. The \texttt{StringEvent} class provides a shallow copy of itself to instantiate its ConcretePrototype, while \texttt{SimpleNetwork::Request} performs a deep copy.

\begin{figure}[h]
  \caption{SST Classes Implementing the Prototype Pattern}
  \centering
  \includegraphics[width=0.8\textwidth]{proto.png}
\end{figure}

The following listings demonstrate the instances of the project following the typical steps dictated by the pattern:

\begin{lstlisting}[style=customC++,label=prototype1,caption=StringEvent Implementing the Prototype Pattern \\ File: src/sst/core/interfaces/stringEvent.h]
class StringEvent : public SST::Event, ... {
  virtual Event* clone() override {
    return new StringEvent(*this);
  }
}
\end{lstlisting}

\begin{lstlisting}[style=customC++,label=prototype2,caption=SimpleNetwork::Request Implementing the Prototype Pattern \\ File: src/sst/core/interfaces/simpleNetwork.h]
class SimpleNetwork : public SubComponent {
  class Request : public ... {
    Request* clone() {
      Request* req = new Request(*this);
      if (payload != nullptr) {
        req->payload = payload->clone();
      }
      return req;
    }
  }
}
\end{lstlisting}
