# Week 9: Compiler Project Conditional IR Gen

The ANTLR4 tool was installed and ran using the instructions in the official documentations, https://github.com/antlr/antlr4/blob/master/doc/getting-started.md.

The tool and its dependencies were installed on the system using `apt`.

The generated files, including the visitor and listener files, are moved to `generated` and the object files in `objects`.

The provided Makefile compiles the main C++ script and links with the runtime library to generate the executable `Cminus`. The symbol table is implemented in the `Symtab.hpp` classes. The semantic predicates are defined in the `SemPred.hpp` classes. These class methods are injected throughout the grammar file to enforce the semantic predicates dictated in Appendix A. The symbols are added and checked by the predicate methods as necessary. The symbol table gets dumped after execution of the main script.

## Modifications made for the assignment

1. The symbol table class in `Symtab.h` had minor updates to organize the symbols by their scopes.

2. Semantic error messages were updated to include line numbers.

3. The derived Visitor class file, `CminusBaseVisitor.h`, was the only file that was modified after being generated by ANTLR4.
   1. The visitor method for `relational_exp` was updated. Relational operators are handled similarly to the already implemented binary operation visitor methods, where the operands are pushed to the expression stack and popped after evaluated.
   2. The visitor method for `selection_stmt` was updated. 3 basic blocks get added for every conditional blocks, and instructions are appended to their respective blocks.

TODO: Currently, generation of IR for selection statements do not utilize Phi nodes and requires the syntax to restrict the statements to be assigned to a variable in the parent scope. i.e. the following snippet:

```
int func(int x, int y) {
   if (x == 1) {
      return y;
   } else {
      return z();
   }
}
```

although syntactically correct, would not be processed properly into IR. Instead, the current implementation expects the following restriction:

```
int func(int x, int y) {
   int r;
   if (x == 1) {
      r = y;
   } else {
      r = z();
   }
   return r;
}
```

## Output files

1. `C-Output-0.sym`, `C-Output-1.sym`, and `C-Output-3.sym` contains the symbol table generated by `C-Input-0.txt`, `C-Input-0.txt`, and `C-Input-3.txt` respectively.
2. `C-Output-0.ll`, `C-Output-1.ll`, and `C-Output-3.ll` contains the IR generated by `C-Input-0.txt`, `C-Input-0.txt`, and `C-Input-3.txt` respectively.

## System

The target machine used was an Ubuntu 20.04 64-bit virtual machine. The Linux kernel version is 5.13.0-30-generic. The following output is generated from running the command `uname -orm`:

```
5.13.0-30-generic x86_64 GNU/Linux
```
