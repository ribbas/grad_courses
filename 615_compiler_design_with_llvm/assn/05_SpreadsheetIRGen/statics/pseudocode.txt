class TableOfCells {
  new attributes:
    init module as LLVM Module;
    init namedValues as map<string: LLVM Value>;

  new methods:
    void generateIR() {
        for (cell : TableOfCells) {
            cell.generateIR();
        }
    }
};

class SS_Cell {
  new methods:
    void generateIR() {
        if (cell can generate IR) {
            cell.codeGen(this);
        }
    }
};

class Node {
  new attributes:
    init irValue as LLVM Value;

  new methods:

    Value codeGen(SS_Cell cell) {

        init cell.module;

        init llvmArgs as vector(
            size = cell.controllers.size(),
            type = LLVM Int32);

        // initialize IR function
        init FT as FunctionType(
            type = type = LLVM Int32,
            params = llvmArgs);
        init func as Function(
            FunctionType = FT,
            Linkage = Function.ExternalLinkage,
            const function name = expName,
            Module = cell.module);

        // set names for all arguments
        for (Arg : func.args()) {
            Arg.setName(cell.controllers.front());
            cell.namedValues[cell.controllers.front()] = &Arg;
        }

        // initialize and insert an empty basic block
        init BasicBlock as BB;
        insert BB into global builder;

        call walkCodeGen(cell.getTOC(), cell);
        insert return(irValue) into global builder;
        assign irValue = return value;

        return irValue;

    }

    void walkCodeGen(TableOfCells TOC, SS_Cell cell) {

        if (node has left child) {
            call left.walkCodeGen(TOC, cell);
        }

        if (node has right child) {
            call right.walkCodeGen(TOC, cell);
        }

        switch (tok.getKind()) {
            case ID: {
                assign irValue = cell.namedValues[tok.getLexeme()];
                return;
            }

            case NUM: {
                assign irValue = LLVM ConstantInt32(tok.getValue());
                return;
            }

            case ADD: {

                insert add(left.irValue, right.irValue) into global builder;
                assign irValue = return value;
                return;
            }

            case SUB: {
                insert sub(left.irValue, right.irValue) into global builder;
                assign irValue = return value;
                return;
            }

            case MULT: {
                insert mult(left.irValue, right.irValue) into global builder;
                assign irValue = return value;
                return;
            }

            case DIV: {
                insert div(left.irValue, right.irValue) into global builder;
                assign irValue = return value;
                return;
            }

            default: {
                irValue = null;
                return;
            }
        }

    }

};
