# Question 1

When developing a complex system, it used to be an easy question for laying out the design; for each independent program, you would create an independent process for that program to run in. Today, we have the ability to design an entire system within the context of a single process, using lightweight threads for individual paths of execution.
The question is, when designing a system, how would you break the design into threads and/or processes? For a system that we are currently developing here at work, we decided to use two processes; one of them is single threaded (and handles network communication), and the other is multi-threaded and handles, well, everything else.
How would you decide how to break a system design up into threads or processes? What are the advantages and disadvantages of using threads vs. processes? Does the platform you are using (e.g. multiple processors vs. uniprocessor machines) make a difference in that decision (or should it)?
Do you even think such a choice ought to be available to the system designer/developer? Perhaps the designer should just specify paths of execution (perhaps using sequence diagrams) and let the execution environment take care of the rest.
For those of you who use java, (which supports threading), would you even consider using muliple processes to implement a java based system? Why or why not?

Also, of course you can address the various questions scattered throughout the module content.
Note that there is no quiz for this module. You need a break. However, I may sprinkle some thread questions in the quiz to be provided with the next module, so don't relax too much.

# Answer 1

A quick anecdote on threads vs processes - I have always had a difficult time distinguishing the two concepts when it came to determining which one to use in a "parallel" program. I haven't always found it necessary to implement my programs to make them run tasks concurrently, but in the rare occasions where I did, I always defaulted to using threads. During my undergrad at a hackathon, when I had just discovered the idea of running separate but concurrent tasks, I used threads to manage multiple tasks on a program. The idea was to handle to handle multiple user authentication and background image-processing tasks simultaneously. I was already aware of race conditions and the relatively simpler method of establishing communication between threads. However, I started to run into issues very quickly after I had realized that any errors on the simpler user authentication tasks would kill the other expensive image-processing tasks. This was mostly since threads are not entirely isolated and share the address space.

On the other hand, in one of my recent projects I have had to deal with parallel computing technology where data were being exchanged over clusters using MPI. One feature that I had worked on was to add interprocess communication (IPC) within the processes in a single node. IPC in several kernels have been actively developed to increase their efficiency, where in some cases third party libraries such as zmq being preferred over the incredibly optimized UNIX domain and web sockets.[1] Even with the vast documentation and relatively friendly API, setting up communication was still fairly difficult. However, the goal of the project was to establish communication between different processes, where some processes may be in a completely different programming language, framework, environment, etc. and therefore, threads were not going to be an easy solution.

I think choosing whether to use threads or processes in a concurrent program ultimately depends on its implementation and performance requirements.

[1] https://zeromq.org/

# Response

Great insight on how Supercollider utilizes processes and threads under the hood, thank you for sharing such an interesting project!

The design decision of the software utilizing multiple processes and threads depending on their use cases reminds me of how popular web browsers similarly treat multiprocessing and multithreading procedures. For example, Chrome and its forks such as Chromium are usually ridiculed for their exorbitant usage of a machine's CPU. However, this is due to the program's multi-process architecture which leads to many duplications in their procedures. [1] If a tab in the browser crashes due to any number of reasons, the program should be able to simply kill that tab without having to sacrifice the other tabs. Multiple tabs running on their own processes also protect data leakage from each other. On top of the multiple processes, these browsers are also heavily reliant on multithreading capabilities.

[1] https://chromium.googlesource.com/chromium/src.git/+/HEAD/docs/threading_and_tasks.md
